âœ… COMPLETED
ğŸ§  1. Non-blocking Server Loop (poll() + socket setup)

What it is:
Youâ€™ve built a server that uses poll() to handle multiple connections without blocking. This means the server can talk to many clients at the same time, even if theyâ€™re slow or not responding.

Why it's required:
The subject explicitly says:

"Your server must remain non-blocking at all times."

If your server used blocking recv() or accept(), it could freeze waiting for a single client. Using poll() lets you avoid that.

ğŸ“ 2. Config Parsing (config.conf)

What it is:
Your server reads settings from a config file â€” just like NGINX or Apache. You support:

listen (port)

server_name

location blocks

root, index, allowed_methods, error_page, upload_path, etc.

Why it's required:
The subject wants your server to be configurable without recompiling. It mimics a real-world HTTP server where admin configures routing, behavior, and limits using a file.

ğŸ“„ 3. Serving Static Files (GET)

What it is:
A request like GET /index.html returns the contents of ./www/index.html.

Why it's required:
A core part of an HTTP server. Users expect the ability to browse and retrieve files. Without this, itâ€™s not a web server.

ğŸš« 4. Custom Error Pages (403, 404)

What it is:
If a file is missing (404) or forbidden (403), your server checks if a custom error page like /404.html is configured and uses it.

Why it's required:
Customizability is key in real servers. Admins donâ€™t want ugly default messages â€” they want control over how errors look.

âš™ï¸ 5. HTTP Response Builder

What it is:
You generate raw HTTP responses with proper headers (Content-Type, Content-Length, etc).

Why it's required:
Clients expect strict adherence to the HTTP/1.1 protocol. Without correct headers, browsers or curl may behave unpredictably.

ğŸŸ¡ IN PROGRESS / PARTIAL
ğŸ—‚ï¸ 6. Routing Logic (Matching Location Blocks)

What it is:
When a user accesses /upload, it should follow settings inside:
	location /upload {
  ...
}
Right now, you're only partially using location settings.

Why it's required:
This is the core mechanism to define different behavior per path (e.g., CGI for /cgi-bin/, uploads for /upload, etc).
Without this, your server behaves the same no matter whatâ€™s requested.

â¬†ï¸ 7. Upload Handling (POST)

What it is:
When a browser sends a form with a file (method POST), your server should read the body, parse it (usually multipart/form-data), and save it in the location set by upload_path.

Why it's required:
Uploading is part of HTTP/1.1 and web forms. The subject asks you to support file uploads, so users can POST files via HTML.

ğŸ§  8. CGI Support (in progress in repo)

What it is:
CGI is a way to execute scripts on the server (e.g., PHP, Python) and return the result as the HTTP response.

You already have a CGIHandler.cpp file. Whatâ€™s missing is connecting it to requests that match location with a cgi_extension.

Why it's required:
The subject requires CGI support â€” this is one of the core challenges. It proves you can:

spawn processes

handle pipes

manage environment variables

work with I/O redirection (dup2)

âœ… 9. allowed_methods (but not enforced yet)

What it is:
You parse the allowed_methods GET POST line in config.conf â€” but donâ€™t yet enforce it. If someone sends DELETE and itâ€™s not allowed, your server should return 405.

Why it's required:
The subject wants you to respect and enforce allowed methods for each location.

âŒ NOT YET IMPLEMENTED
ğŸ“‚ 10. Autoindex

What it is:
If someone accesses a directory like /files/ and no index.html exists, but autoindex on; is set â€” your server should return a dynamically-generated HTML list of files in that directory.

Why it's required:
This is a required feature per subject and mimics autoindex in NGINX.

ğŸ“¬ 11. Full Body Parsing (for POST, CGI, uploads)

What it is:
Your current handleClientRead doesnâ€™t wait for body content (e.g., in a POST). It just reads until \r\n\r\n.

Why it's required:
To upload files or run CGI scripts that read from stdin, you must:

wait until Content-Length bytes are received

pass the body properly

âŒ 12. Method Enforcement

What it is:
If a method is not listed in allowed_methods, return 405 Method Not Allowed.

Why it's required:
The subject says:

You must handle 405 Method Not Allowed if method is disallowed by location config.

âš™ï¸ 13. CGI Integration (missing)

What it is:
The code exists but is not plugged into the request handler. You must:

detect when a location matches .php or .py

fork + dup2

wait on child

use response

Why it's required:
Mandatory for full marks. Also one of the most complex parts (pipes, env, fork).

ğŸŒ 14. HTTP/1.1 Features (Keep-Alive, etc.)

What it is:
Your server closes the connection after every response. Thatâ€™s fine, but HTTP/1.1 allows persistent connections. Itâ€™s optional but nice.

Why it's optional:
Subject doesnâ€™t require full spec â€” just core behavior. But this is a bonus-level polish.

ğŸ¯ Overall Summary
Category	Features	Status
Core Socket Server	Non-blocking, poll(), accept(), read/write	âœ… Done
Config System	Fully working parser with location support	âœ… Done
Static File Handling	200, 403, 404, custom error pages	âœ… Done
HTTP Parser	Simplified GET/POST (no full body)	ğŸŸ¡ Partial
Routing Logic	Location-based settings partially respected	ğŸŸ¡ Partial
Upload & POST	Upload logic present, not wired in	ğŸŸ¡ Partial
CGI Support	Code exists, not plugged in	ğŸŸ¡ Partial
Method Checks	Parsed but not enforced	âŒ Missing
Autoindex	Directory listing not implemented	âŒ Missing
Bonus / Polishing	Logging, Keep-Alive, HTTPS, etc.	âŒ Optional